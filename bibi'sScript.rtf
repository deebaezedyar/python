{\rtf1\ansi\ansicpg1252\cocoartf2636
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 HelveticaNeue;}
{\colortbl;\red255\green255\blue255;\red27\green27\blue27;\red226\green229\blue249;}
{\*\expandedcolortbl;;\cssrgb\c14118\c14118\c14118;\cssrgb\c90980\c92157\c98039;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 file_mapper = \{'1_binary_landscapes.txt': '1_binary_landscapes_output.txt',\cb1 \uc0\u8232 \cb3 '10_computable_moments.txt': '10_computable_moments_output.txt',\cb1 \uc0\u8232 \cb3 '10_computable_moments_p.txt': '10_computable_moments_output_p.txt',\cb1 \uc0\u8232 \cb3 '0_example.txt': '0_example_output.txt'\cb1 \uc0\u8232 \cb3 \}\
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb1 \uc0\u8232 \cb3 def sort(file_name):\cb1 \uc0\u8232 \cb3 result = \{\}\cb1 \uc0\u8232 \cb3 with open(f"/Users/deeba/Desktop/\{file_name\}") as f:\cb1 \uc0\u8232 \cb3 lines = f.readlines()\cb1 \uc0\u8232 \cb3 current_index = 1\cb1 \uc0\u8232 \cb3 while current_index < len(lines) - 1:\cb1 \uc0\u8232 \cb3 value = lines[current_index].split(" ")[1]\cb1 \uc0\u8232 \cb3 result[current_index] = value\cb1 \uc0\u8232 \cb3 current_index += 1\cb1 \uc0\u8232 \cb3 result = \{k: v for k, v in sorted(result.items(), key=lambda item: item[1])\}\cb1 \uc0\u8232 \cb3 file_content = [len(result.keys()) + "\\n"]\cb1 \uc0\u8232 \cb3 for key in result.keys():\cb1 \uc0\u8232 \cb3 file_content.append(key + "\\n")\cb1 \uc0\u8232 \cb3 with open(f"/Users/deeba/\{file_mapper[file_name]\}", "w") as f:\cb1 \uc0\u8232 \cb3 f.writelines(file_content)\
\
\cb1 \uc0\u8232 \cb3 def group_items(file_name):\cb1 \uc0\u8232 \cb3 landscape_dict = \{\}\cb1 \uc0\u8232 \cb3 portrait_dict = \{\}\cb1 \uc0\u8232 \cb3 with open(f"/Users/deeba/\{file_name\}") as f:\cb1 \uc0\u8232 \cb3 lines = f.readlines()\cb1 \uc0\u8232 \cb3 current_index = 1\cb1 \uc0\u8232 \cb3 while current_index < len(lines):\cb1 \uc0\u8232 \cb3 tags = int(lines[current_index].split(" ")[1])\cb1 \uc0\u8232 \cb3 if lines[current_index][0] == 'L':\cb1 \uc0\u8232 \cb3 landscape_dict[current_index] = tags\cb1 \uc0\u8232 \cb3 else:\cb1 \uc0\u8232 \cb3 portrait_dict[current_index] = tags\cb1 \uc0\u8232 \cb3 current_index += 1\cb1 \uc0\u8232 \cb3 result_lines = []\cb1 \uc0\u8232 \cb3 landscape_dict = sort_dictionary(landscape_dict)\cb1 \uc0\u8232 \cb3 for key in landscape_dict.keys():\cb1 \uc0\u8232 \cb3 result_lines.append(f"\{key\}" + "\\n")\cb1 \uc0\u8232 \cb3 with open("/Users/deeba/inter_mediate_file.txt", "w") as f:\cb1 \uc0\u8232 \cb3 f.write(f"\{len(result_lines)\} \\n")\cb1 \uc0\u8232 \cb3 f.writelines(result_lines)\
\
portrait_dict = sort_dictionary(portrait_dict)\cb1 \uc0\u8232 \cb3 print(sort_dictionary(landscape_dict))\
\
\cb1 \uc0\u8232 \cb3 def sort_dictionary(data, reverse=False):\cb1 \uc0\u8232 \cb3 return \{k: v for k, v in sorted(data.items(), key=lambda item: item[1], reverse=reverse)\}\
\
\cb1 \uc0\u8232 \cb3 def create_frame_glass(input_file):\cb1 \uc0\u8232 \cb3 frame_glasses = []\cb1 \uc0\u8232 \cb3 with open(f"/Users/deeba/\{input_file\}") as f:\cb1 \uc0\u8232 \cb3 lines_of_paintings = f.readlines()\cb1 \uc0\u8232 \cb3 lines_of_paintings = lines_of_paintings[1:]\cb1 \uc0\u8232 \cb3 for index, painting in enumerate(lines_of_paintings):\cb1 \uc0\u8232 \cb3 frame_glasses.append(\{\cb1 \uc0\u8232 \cb3 'index': index,\cb1 \uc0\u8232 \cb3 'tags': get_tags(painting),\cb1 \uc0\u8232 \cb3 'image': painting[0]\cb1 \uc0\u8232 \cb3 \})\cb1 \uc0\u8232 \cb3 landscape_paintings = split_frames(frame_glasses)\cb1 \uc0\u8232 \cb3 portraits_paintings = merge_portraits(split_frames(frame_glasses, 'P'))\cb1 \uc0\u8232 \cb3 merged_frame_glass = landscape_paintings + portraits_paintings\cb1 \uc0\u8232 \cb3 size = len(merged_frame_glass)\cb1 \uc0\u8232 \cb3 results = [merged_frame_glass[0]]\cb1 \uc0\u8232 \cb3 keys = [str(merged_frame_glass[0]['index'])]\cb1 \uc0\u8232 \cb3 pointer = 0\cb1 \uc0\u8232 \cb3 for i in range(size):\cb1 \uc0\u8232 \cb3 source_tags = results[pointer]['tags']\cb1 \uc0\u8232 \cb3 score_dictionary = \{\}\cb1 \uc0\u8232 \cb3 for j in range(i + 1, size):\cb1 \uc0\u8232 \cb3 destination_tags = merged_frame_glass[j]['tags']\cb1 \uc0\u8232 \cb3 distance = calculate_similarity(source_tags, destination_tags)\cb1 \uc0\u8232 \cb3 score_dictionary[j] = distance\cb1 \uc0\u8232 \cb3 score_dictionary = sort_dictionary(score_dictionary, reverse=True)\cb1 \uc0\u8232 \cb3 if len(list(score_dictionary)) > 0:\cb1 \uc0\u8232 \cb3 for key in score_dictionary:\cb1 \uc0\u8232 \cb3 if str(merged_frame_glass[key]['index']) not in keys:\cb1 \uc0\u8232 \cb3 results.append(merged_frame_glass[key])\cb1 \uc0\u8232 \cb3 keys.append(str(merged_frame_glass[key]['index']))\cb1 \uc0\u8232 \cb3 pointer += 1\cb1 \uc0\u8232 \cb3 break\cb1 \uc0\u8232 \cb3 all_keys = [str(glass['index']) for glass in merged_frame_glass]\cb1 \uc0\u8232 \cb3 remaining_keys = set(all_keys) - set(keys)\
\
with open(f"/Users/deeba/\{file_mapper[input_file]\}", "w") as f:\cb1 \uc0\u8232 \cb3 lines = []\cb1 \uc0\u8232 \cb3 count = f"\{len(results) + len(remaining_keys)\} \\n"\cb1 \uc0\u8232 \cb3 lines.append(count)\cb1 \uc0\u8232 \cb3 for line in results:\cb1 \uc0\u8232 \cb3 identifier = str(line['index']) + "\\n"\cb1 \uc0\u8232 \cb3 lines.append(identifier)\cb1 \uc0\u8232 \cb3 f.writelines(lines)\cb1 \uc0\u8232 \cb3 remaining_lines = []\cb1 \uc0\u8232 \cb3 for key in remaining_keys:\cb1 \uc0\u8232 \cb3 remaining_lines.append(f"\{key\}\\n")\cb1 \uc0\u8232 \cb3 f.writelines(remaining_lines)\
\
\cb1 \uc0\u8232 \cb3 def generate_output(sorted_dict, output_file):\cb1 \uc0\u8232 \cb3 output_lines = []\cb1 \uc0\u8232 \cb3 keys = []\cb1 \uc0\u8232 \cb3 for key in sorted_dict.keys():\cb1 \uc0\u8232 \cb3 first, second = key.split("-")\cb1 \uc0\u8232 \cb3 if first not in keys:\cb1 \uc0\u8232 \cb3 keys.append(first)\cb1 \uc0\u8232 \cb3 output_lines.append(f"\{first\} \\n")\cb1 \uc0\u8232 \cb3 if second not in keys:\cb1 \uc0\u8232 \cb3 keys.append(second)\cb1 \uc0\u8232 \cb3 output_lines.append(f"\{second\} \\n")\
\
with open(f"/Users/deeba/\{file_mapper[output_file]\}", "w") as w:\cb1 \uc0\u8232 \cb3 w.write(str(len(output_lines)) + "\\n")\cb1 \uc0\u8232 \cb3 w.writelines(output_lines)\
\
\cb1 \uc0\u8232 \cb3 def calculate_similarity(a, b):\cb1 \uc0\u8232 \cb3 set_a = set(a)\cb1 \uc0\u8232 \cb3 set_b = set(b)\cb1 \uc0\u8232 \cb3 value = min([len(set_a - set_b), len(set_a.intersection(set_b)), len(set_b - set_a)])\cb1 \uc0\u8232 \cb3 return value\
\
\cb1 \uc0\u8232 \cb3 def merge_portraits(paintings: list):\cb1 \uc0\u8232 \cb3 results = []\cb1 \uc0\u8232 \cb3 current_index = 0\cb1 \uc0\u8232 \cb3 condition = len(paintings) - 2 if len(paintings) % 2 == 0 else len(paintings) - 3\cb1 \uc0\u8232 \cb3 while current_index <= condition:\cb1 \uc0\u8232 \cb3 index_1 = paintings[current_index]['index']\cb1 \uc0\u8232 \cb3 index_2 = paintings[current_index + 1]['index']\cb1 \uc0\u8232 \cb3 tags = set(paintings[current_index]['tags']).union(set(paintings[current_index + 1]['tags']))\cb1 \uc0\u8232 \cb3 results.append(\{\cb1 \uc0\u8232 \cb3 'index': f"\{index_1\} \{index_2\}",\cb1 \uc0\u8232 \cb3 'tags': tags,\cb1 \uc0\u8232 \cb3 'image': 'P'\cb1 \uc0\u8232 \cb3 \})\cb1 \uc0\u8232 \cb3 current_index += 2\cb1 \uc0\u8232 \cb3 return results\
\
\cb1 \uc0\u8232 \cb3 def split_frames(frame_glasses: dict, image='L'):\cb1 \uc0\u8232 \cb3 return [frame_glass for frame_glass in frame_glasses if frame_glass['image'] == image]\
\
\cb1 \uc0\u8232 \cb3 def present_in_portrait(index, portrait_paintings):\cb1 \uc0\u8232 \cb3 return index == int(portrait_paintings[0]['index'])\
\
\cb1 \uc0\u8232 \cb3 def look_for_portrait_pair(portrait_paintings):\cb1 \uc0\u8232 \cb3 p0 = portrait_paintings[0]\cb1 \uc0\u8232 \cb3 index_1 = p0['index']\cb1 \uc0\u8232 \cb3 if len(portrait_paintings) == 1:\cb1 \uc0\u8232 \cb3 return \{\cb1 \uc0\u8232 \cb3 'index': f'\{index_1\}',\cb1 \uc0\u8232 \cb3 'tags': p0['tags']\cb1 \uc0\u8232 \cb3 \}\cb1 \uc0\u8232 \cb3 else:\cb1 \uc0\u8232 \cb3 p1 = portrait_paintings[1]\cb1 \uc0\u8232 \cb3 index_2 = p1['index']\cb1 \uc0\u8232 \cb3 tags = set(p0['tags']).union(set(p1['tags']))\cb1 \uc0\u8232 \cb3 return \{\cb1 \uc0\u8232 \cb3 'index': f'\{index_1\} \{index_2\}',\cb1 \uc0\u8232 \cb3 'tags': tags,\cb1 \uc0\u8232 \cb3 'image': 'p'\cb1 \uc0\u8232 \cb3 \}\
\
\cb1 \uc0\u8232 \cb3 def is_portrait(painting):\cb1 \uc0\u8232 \cb3 return painting[0] == 'P'\
\
\cb1 \uc0\u8232 \cb3 def get_tags(painting):\cb1 \uc0\u8232 \cb3 painting = painting.replace("\\n", "")\cb1 \uc0\u8232 \cb3 columns = painting.split(" ")\cb1 \uc0\u8232 \cb3 return columns[2:]\
\
\cb1 \uc0\u8232 \cb3 def filter_portrait_paintings(paintings):\cb1 \uc0\u8232 \cb3 portrait_paintings = []\cb1 \uc0\u8232 \cb3 current_index = 1\cb1 \uc0\u8232 \cb3 while current_index < len(paintings) - 1:\cb1 \uc0\u8232 \cb3 painting = paintings[current_index]\cb1 \uc0\u8232 \cb3 painting = painting.replace("\\n", "")\cb1 \uc0\u8232 \cb3 columns = painting.split(" ")\cb1 \uc0\u8232 \cb3 if columns[0] == 'P':\cb1 \uc0\u8232 \cb3 portrait_paintings.append(\{\cb1 \uc0\u8232 \cb3 "index": current_index,\cb1 \uc0\u8232 \cb3 "tags": columns[2:],\cb1 \uc0\u8232 \cb3 "image": columns[0]\cb1 \uc0\u8232 \cb3 \})\cb1 \uc0\u8232 \cb3 current_index += 1\cb1 \uc0\u8232 \cb3 return portrait_paintings\
\
\cb1 \uc0\u8232 \cb3 create_frame_glass("1_binary_landscapes.txt")\
}